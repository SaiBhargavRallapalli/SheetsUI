package com.rsb.sheetsui.data.repository

import android.util.Log
import com.rsb.sheetsui.data.remote.api.GoogleFormsService
import com.rsb.sheetsui.data.remote.dto.forms.BatchUpdateRequestDto
import com.rsb.sheetsui.data.remote.dto.forms.ChoiceOptionDto
import com.rsb.sheetsui.data.remote.dto.forms.ChoiceQuestionDto
import com.rsb.sheetsui.data.remote.dto.forms.CreateItemRequestDto
import com.rsb.sheetsui.data.remote.dto.forms.FormBatchUpdateRequestDto
import com.rsb.sheetsui.data.remote.dto.forms.FormCreateRequestDto
import com.rsb.sheetsui.data.remote.dto.forms.FormCreateResponseDto
import com.rsb.sheetsui.data.remote.dto.forms.FormInfoDto
import com.rsb.sheetsui.data.remote.dto.forms.FormItemDto
import com.rsb.sheetsui.data.remote.dto.forms.FormLocationDto
import com.rsb.sheetsui.data.remote.dto.forms.FormQuestionDto
import com.rsb.sheetsui.data.remote.dto.forms.QuestionItemDto
import com.rsb.sheetsui.data.remote.dto.forms.TextQuestionDto
import com.rsb.sheetsui.data.remote.dto.forms.DateQuestionDto
import com.rsb.sheetsui.data.remote.dto.forms.UpdateFormInfoRequestDto
import com.rsb.sheetsui.domain.inference.SheetInferenceEngine
import com.rsb.sheetsui.domain.model.ColumnValidation
import com.rsb.sheetsui.domain.model.FieldType
import com.rsb.sheetsui.domain.model.SheetData
import com.rsb.sheetsui.domain.repository.CreatedForm
import com.rsb.sheetsui.domain.repository.FormRepository
import javax.inject.Inject
import javax.inject.Singleton

private const val TAG = "FormRepository"

@Singleton
class FormRepositoryImpl @Inject constructor(
    private val formsService: GoogleFormsService
) : FormRepository {

    override suspend fun createStandaloneForm(formTitle: String): Result<CreatedForm> = runCatching {
        val title = formTitle.ifBlank { "Untitled form" }
        val createBody = FormCreateRequestDto(
            info = FormInfoDto(title = title, documentTitle = title)
        )
        val createResp = formsService.createForm(createBody)
        if (!createResp.isSuccessful) {
            val err = createResp.errorBody()?.string()
            Log.e(TAG, "Forms create failed ${createResp.code()}: $err")
            throw Exception(formatFormError(createResp.code(), err))
        }

        val form = createResp.body() ?: throw Exception("Empty create response")
        val formId = form.formId ?: throw Exception("No formId in response")

        // Add one default text question + form description (Step 3: Publishing & Security)
        val batchBody = FormBatchUpdateRequestDto(
            includeFormInResponse = true,
            requests = listOf(
                BatchUpdateRequestDto(
                    createItem = CreateItemRequestDto(
                        item = FormItemDto(
                            title = "Question 1",
                            questionItem = QuestionItemDto(
                                question = FormQuestionDto(
                                    required = false,
                                    textQuestion = TextQuestionDto(paragraph = false)
                                )
                            )
                        ),
                        location = FormLocationDto(index = 0)
                    )
                ),
                BatchUpdateRequestDto(
                    updateFormInfo = UpdateFormInfoRequestDto(
                        info = FormInfoDto(
                            title = title,
                            documentTitle = title,
                            description = "This form was automatically generated by SheetsUI."
                        ),
                        updateMask = "description"
                    )
                )
            )
        )
        val batchResp = formsService.batchUpdateForm(formId, batchBody)
        if (!batchResp.isSuccessful) {
            val err = batchResp.errorBody()?.string()
            Log.e(TAG, "Forms batchUpdate failed ${batchResp.code()}: $err")
            // Form was created; return it even if adding question failed
        }

        val updatedForm = batchResp.body()?.form ?: form
        val responderUri = updatedForm.responderUri ?: "https://docs.google.com/forms/d/$formId/viewform"

        CreatedForm(
            formId = formId,
            responderUri = responderUri,
            formTitle = title
        )
    }

    private fun formatFormError(code: Int, errorBody: String?): String = when (code) {
        401 -> "Authorization failed. Please sign out and sign in again to grant permissions."
        403 -> "Form creation failed (403). Enable Google Forms API in Google Cloud Console."
        else -> "Failed to create form ($code)"
    }

    override suspend fun createFormFromHeaders(
        formTitle: String,
        headers: List<String>,
        headerTypes: Map<Int, FieldType>?
    ): Result<CreatedForm> = runCatching {
        val filteredHeaders = headers.filter { it.isNotBlank() }
        if (filteredHeaders.isEmpty()) {
            throw IllegalArgumentException("At least one header required")
        }

        val createBody = FormCreateRequestDto(
            info = FormInfoDto(title = formTitle, documentTitle = formTitle)
        )
        val createResp = formsService.createForm(createBody)
        if (!createResp.isSuccessful) {
            val err = createResp.errorBody()?.string()
            Log.e(TAG, "Forms create failed ${createResp.code()}: $err")
            throw Exception(formatFormError(createResp.code(), err))
        }

        val form = createResp.body() ?: throw Exception("Empty create response")
        val formId = form.formId ?: throw Exception("No formId in response")

        val requests = filteredHeaders.mapIndexed { index, header ->
            val fieldType = headerTypes?.get(index) ?: inferFieldType(header)
            val question = when (fieldType) {
                FieldType.DATE -> FormQuestionDto(
                    required = false,
                    dateQuestion = DateQuestionDto(includeTime = false, includeYear = true)
                )
                FieldType.NUMBER, FieldType.CURRENCY -> FormQuestionDto(
                    required = false,
                    textQuestion = TextQuestionDto(paragraph = false)
                )
                else -> FormQuestionDto(
                    required = false,
                    textQuestion = TextQuestionDto(paragraph = false)
                )
            }
            val description = when (fieldType) {
                FieldType.NUMBER, FieldType.CURRENCY -> "Enter numbers only."
                else -> null
            }
            BatchUpdateRequestDto(
                createItem = CreateItemRequestDto(
                    item = FormItemDto(
                        title = header,
                        description = description,
                        questionItem = QuestionItemDto(question = question)
                    ),
                    location = FormLocationDto(index = index)
                )
            )
        }

        val batchBody = FormBatchUpdateRequestDto(
            includeFormInResponse = true,
            requests = requests
        )
        val batchResp = formsService.batchUpdateForm(formId, batchBody)
        if (!batchResp.isSuccessful) {
            val err = batchResp.errorBody()?.string()
            Log.e(TAG, "Forms batchUpdate failed ${batchResp.code()}: $err")
            throw Exception("Failed to add questions (${batchResp.code()})")
        }

        val updatedForm = batchResp.body()?.form ?: form
        val responderUri = updatedForm.responderUri ?: "https://docs.google.com/forms/d/$formId/viewform"

        CreatedForm(
            formId = formId,
            responderUri = responderUri,
            formTitle = formTitle
        )
    }

    override suspend fun createFormFromSpreadsheet(
        spreadsheetId: String,
        spreadsheetName: String,
        sheetData: SheetData
    ): Result<CreatedForm> = runCatching {
        val sampleRow = sheetData.rows.firstOrNull() ?: emptyList()
        val formulaRow = sheetData.formulaRows.firstOrNull()
        val fieldTypes = SheetInferenceEngine.infer(
            sheetData.headers,
            sampleRow,
            formulaRow,
            userOverrides = null
        )

        val createBody = FormCreateRequestDto(
            info = FormInfoDto(
                title = spreadsheetName,
                documentTitle = spreadsheetName
            )
        )
        val createResp = formsService.createForm(createBody)
        if (!createResp.isSuccessful) {
            val err = createResp.errorBody()?.string()
            Log.e(TAG, "Forms create failed ${createResp.code()}: $err")
            throw Exception(formatFormError(createResp.code(), err))
        }

        val form = createResp.body() ?: throw Exception("Empty create response")
        val formId = form.formId ?: throw Exception("No formId in response")
        val responderUri = form.responderUri ?: "https://docs.google.com/forms/d/$formId/viewform"

        val createItemRequests = buildFormItems(
            headers = sheetData.headers,
            fieldTypes = fieldTypes,
            columnValidations = sheetData.columnValidations
        )
        if (createItemRequests.isEmpty()) {
            throw IllegalArgumentException("No valid headers to create form from. Skip 'ID', 'Timestamp', or hidden columns.")
        }

        val requests = buildList {
            addAll(createItemRequests.mapIndexed { index, req ->
                BatchUpdateRequestDto(
                    createItem = CreateItemRequestDto(
                        item = req,
                        location = FormLocationDto(index = index)
                    )
                )
            })
            add(
                BatchUpdateRequestDto(
                    updateFormInfo = UpdateFormInfoRequestDto(
                        info = FormInfoDto(
                            title = spreadsheetName,
                            documentTitle = spreadsheetName,
                            description = "This form was automatically generated by SheetsUI."
                        ),
                        updateMask = "description"
                    )
                )
            )
        }

        val batchBody = FormBatchUpdateRequestDto(
            includeFormInResponse = true,
            requests = requests
        )
        val batchResp = formsService.batchUpdateForm(formId, batchBody)
        if (!batchResp.isSuccessful) {
            val err = batchResp.errorBody()?.string()
            Log.e(TAG, "Forms batchUpdate failed ${batchResp.code()}: $err")
            throw Exception("Failed to add questions (${batchResp.code()})")
        }

        val updatedForm = batchResp.body()?.form ?: form
        val finalResponderUri = updatedForm.responderUri ?: responderUri

        CreatedForm(
            formId = formId,
            responderUri = finalResponderUri,
            formTitle = spreadsheetName
        )
    }

    private fun buildFormItems(
        headers: List<String>,
        fieldTypes: List<FieldType>,
        columnValidations: Map<Int, ColumnValidation>
    ): List<FormItemDto> {
        val result = mutableListOf<FormItemDto>()
        headers.forEachIndexed { index, header ->
            val trimmed = header.trim()
            if (trimmed.isBlank()) return@forEachIndexed
            val lower = trimmed.lowercase()
            if (lower == "id" || lower == "timestamp") return@forEachIndexed

            val fieldType = fieldTypes.getOrElse(index) { FieldType.TEXT }
            if (fieldType == FieldType.FORMULA) return@forEachIndexed

            val validation = columnValidations[index]
            val question = when {
                validation is ColumnValidation.Dropdown && validation.options.isNotEmpty() -> FormQuestionDto(
                    required = false,
                    choiceQuestion = ChoiceQuestionDto(
                        type = "DROP_DOWN",
                        options = validation.options.map { ChoiceOptionDto(value = it) }
                    )
                )
                fieldType == FieldType.DATE -> FormQuestionDto(
                    required = false,
                    dateQuestion = DateQuestionDto(includeTime = false, includeYear = true)
                )
                fieldType == FieldType.NUMBER || fieldType == FieldType.CURRENCY -> FormQuestionDto(
                    required = false,
                    textQuestion = TextQuestionDto(paragraph = false)
                )
                else -> FormQuestionDto(
                    required = false,
                    textQuestion = TextQuestionDto(paragraph = false)
                )
            }
            val description = when (fieldType) {
                FieldType.NUMBER, FieldType.CURRENCY -> "Enter numbers only."
                else -> null
            }
            result.add(
                FormItemDto(
                    title = trimmed,
                    description = description,
                    questionItem = QuestionItemDto(question = question)
                )
            )
        }
        return result
    }

    private fun inferFieldType(header: String): FieldType {
        val lower = header.lowercase()
        return when {
            lower.contains("date") || lower.contains("due") -> FieldType.DATE
            lower.contains("price") || lower.contains("amount") || lower.contains("total") || lower.contains("cost") ->
                FieldType.CURRENCY
            lower.contains("number") || lower.contains("count") || lower.contains("quantity") ->
                FieldType.NUMBER
            lower.contains("yes") || lower.contains("no") || lower.contains("status") -> FieldType.BOOLEAN
            else -> FieldType.TEXT
        }
    }
}
